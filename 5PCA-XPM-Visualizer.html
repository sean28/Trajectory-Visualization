<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>XPM Heatmap Visualizer (pure frontend)</title>
  <script src="./plotly-latest.min.js"></script>
  <style>
    body{font-family:Arial, sans-serif;background:#f5f6fa;margin:0;padding:2rem;}
    .container{max-width:1100px;margin:auto;background:#fff;padding:2rem;border-radius:12px;box-shadow:0 0 10px rgba(0,0,0,.05);}
    h2{text-align:center;margin-bottom:1rem;}
    .form-group{margin-bottom:1rem;}
    label{display:block;margin-bottom:.35rem;font-weight:bold;}
    input[type="text"],input[type="number"],select{
      width:100%;padding:.5rem .6rem;border:1px solid #ccc;border-radius:8px;font-size:14px;outline:none;transition:.2s;
    }
    input[type="text"]:focus,input[type="number"]:focus,select:focus{border-color:#007bff;}
    .row{display:flex;gap:1rem;flex-wrap:wrap;}
    .col{flex:1;min-width:220px}
    .file-row{display:flex;align-items:center;gap:.6rem;flex-wrap:wrap}
    button{padding:.55rem 1.1rem;border:none;background:#007bff;color:#fff;border-radius:8px;cursor:pointer}
    button:hover{background:#0056b3}
    #plot{margin-top:1rem;}
    #meta{font-family:monospace;background:#f7f7f7;padding:1rem;border-radius:8px;white-space:pre-wrap}
  </style>
</head>
<body>
<div class="container">
  <h2>Covariance XPM → Heatmap (No Backend)</h2>

  <div class="form-group">
    <div class="file-row">
      <label class="col" style="flex:2;min-width:320px;">Upload .xpm (e.g., covar.xpm)
        <input type="file" id="xpmFile" accept=".xpm">
      </label>
      <div class="file-row">
        <button onclick="drawXPM()">Plot</button>
        <button onclick="downloadPNG()">Download PNG</button>
      </div>
    </div>
  </div>

  <div class="form-group">
    <div class="row">
      <div class="col">
        <label>Figure Size (width,height)</label>
        <input id="figSize" type="text" value="1000,760">
      </div>
      <div class="col">
        <label>Downsample (step)</label>
        <input id="downsample" type="number" min="1" step="1" value="1">
      </div>
      <div class="col">
        <label>Axis Ticks (dtick X,Y)</label>
        <input id="dtick" type="text" placeholder="auto,auto" value="">
      </div>
      <div class="col">
        <label>Axis Range (Xmin,Xmax)</label>
        <input id="xrange" type="text" placeholder="auto">
      </div>
      <div class="col">
        <label>Axis Range (Ymin,Ymax)</label>
        <input id="yrange" type="text" placeholder="auto">
      </div>
    </div>
  </div>

  <div class="form-group">
    <div class="row">
      <div class="col">
        <label>Use XPM Palette</label>
        <select id="cmapMode">
          <option value="xpm" selected>From XPM</option>
          <option value="Viridis">Viridis</option>
          <option value="Turbo">Turbo</option>
          <option value="Jet">Jet</option>
          <option value="Cividis">Cividis</option>
          <option value="Greys">Greys</option>
        </select>
      </div>
      <div class="col">
        <label>Flip</label>
        <div style="display:inline-flex;align-items:center;gap:10px;">
          <label><input type="checkbox" id="flipud"> Flip Up/Down</label>
          <label><input type="checkbox" id="fliplr"> Flip Left/Right</label>
        </div>
      </div>
      <div class="col">
        <label>Numeric Colorbar Min,Max (optional)</label>
        <input id="numMinMax" type="text" placeholder="e.g. -0.2,0.4 (leave blank to use palette index)">
      </div>
      <div class="col">
        <label>Title</label>
        <input id="titleInput" type="text" placeholder="auto from XPM or custom">
      </div>
      <div class="col">
        <label>Axis Labels (X,Y)</label>
        <input id="axisLabels" type="text" placeholder="Index i,Index j">
      </div>
    </div>
  </div>

  <div id="plot"></div>

  <div class="form-group">
    <label>Parsed Meta:</label>
    <div id="meta"></div>
  </div>
</div>

<script>
  // ---------- helpers ----------
  function hexToRGB(hex){
    hex = hex.trim();
    if(!hex.startsWith('#')) return null;
    if(hex.length === 4){ hex = '#' + hex[1]+hex[1] + hex[2]+hex[2] + hex[3]+hex[3]; }
    if(hex.length !== 7) return null;
    const r = parseInt(hex.slice(1,3), 16)/255;
    const g = parseInt(hex.slice(3,5), 16)/255;
    const b = parseInt(hex.slice(5,7), 16)/255;
    return [r,g,b];
  }
  function buildColorscaleFromPalette(palette){
    if(!palette || palette.length===0) return 'Greys';
    if(palette.length===1){
      const rgb = palette[0].map(v=>Math.round(v*255)).join(',');
      return [[0, `rgb(${rgb})`],[1, `rgb(${rgb})`]];
    }
    const cs = [];
    const n = palette.length;
    for(let i=0;i<n;i++){
      const t = i/(n-1);
      const rgb = palette[i].map(v=>Math.round(v*255)).join(',');
      cs.push([t, `rgb(${rgb})`]);
    }
    return cs;
  }
  function downsampleMatrix(z, step){
    if(step <= 1) return z;
    const H = Math.floor(z.length / step);
    const W = Math.floor(z[0].length / step);
    const out = new Array(H);
    for(let r=0;r<H;r++){
      const row = new Array(W);
      for(let c=0;c<W;c++){
        row[c] = z[r*step][c*step];
      }
      out[r] = row;
    }
    return out;
  }

  // ---------- robust XPM parser (find real numeric header) ----------
  function parseXPM(file){
    return new Promise((resolve, reject)=>{
      const reader = new FileReader();
      reader.onload = ()=>{
        const all = reader.result.split(/\r?\n/);

        // collect quoted strings
        const quoted = [];
        for(const ln of all){
          const m = ln.match(/"(.*)"/);
          if(m) quoted.push(m[1]);
        }
        if(quoted.length===0){ reject(new Error("No quoted strings found – not an XPM?")); return; }

        // find the first line like "width height ncolors cpp"
        const headerIdx = quoted.findIndex(s => /^\s*\d+\s+\d+\s+\d+\s+\d+/.test(s));
        if(headerIdx < 0){ reject(new Error("XPM header not found (no 'width height ncolors cpp')")); return; }

        const headNums = quoted[headerIdx].trim().split(/\s+/).map(Number);
        if(headNums.length < 4 || headNums.slice(0,4).some(v=>Number.isNaN(v))){
          reject(new Error("Malformed XPM header (cannot parse 4 numbers)")); return;
        }
        const [width, height, ncolors, cpp] = headNums;

        // color table
        if(headerIdx + 1 + ncolors > quoted.length){
          reject(new Error("Color table truncated in XPM")); return;
        }
        const palette = [];
        const code2idx = new Map();
        const noneKeys = new Set();
        for(let i=0;i<ncolors;i++){
          const ent = quoted[headerIdx + 1 + i];
          const code = ent.slice(0, cpp);
          const hexMatch = ent.match(/#[0-9A-Fa-f]{6}/);
          const isNone = /\bc\s+None\b/i.test(ent);
          let rgb;
          if(hexMatch){
            const H = hexMatch[0];
            const toRGB = h => {
              const hh = h.length===4 ? '#' + h[1]+h[1] + h[2]+h[2] + h[3]+h[3] : h;
              return [
                parseInt(hh.slice(1,3),16)/255,
                parseInt(hh.slice(3,5),16)/255,
                parseInt(hh.slice(5,7),16)/255
              ];
            };
            rgb = toRGB(H);
          }else if(isNone){
            noneKeys.add(code);
            rgb = [1,1,1];
          }else{
            const name = (ent.match(/\bc\s+([A-Za-z]+)/)?.[1]||'').toLowerCase();
            const table = {black:[0,0,0], white:[1,1,1], red:[1,0,0], green:[0,1,0], blue:[0,0,1], yellow:[1,1,0], cyan:[0,1,1], magenta:[1,0,1]};
            rgb = table[name] ?? [0.8,0.8,0.8];
          }
          palette.push(rgb);
          code2idx.set(code, i);
        }

        // pixel rows
        const rowStart = headerIdx + 1 + ncolors;
        const rows = quoted.slice(rowStart, rowStart + height);
        if(rows.length < height){ reject(new Error(`Pixel rows missing: expect ${height}, got ${rows.length}`)); return; }

        const z = new Array(height);
        for(let r=0;r<height;r++){
          const line = rows[r];
          if(line.length < width*cpp){ reject(new Error(`Row ${r} too short: len=${line.length} < ${width*cpp}`)); return; }
          const row = new Array(width);
          for(let c=0;c<width;c++){
            const key = line.substr(c*cpp, cpp);
            if(noneKeys.has(key)){ row[c] = NaN; continue; }
            const idx = code2idx.get(key);
            row[c] = (idx !== undefined) ? idx : NaN;
          }
          z[r] = row;
        }

        // optional meta from comments
        const txt = all.join("\n");
        const grab = rgx => (txt.match(rgx)?.[1]||'').trim();
        const meta = {
          title:  grab(/\/\*.*?title\s*:\s*([^*\n]+).*?\*\//is) || undefined,
          xlabel: grab(/\/\*.*?x-?label\s*:\s*([^*\n]+).*?\*\//is) || undefined,
          ylabel: grab(/\/\*.*?y-?label\s*:\s*([^*\n]+).*?\*\//is) || undefined,
          legend: grab(/\/\*.*?legend\s*:\s*([^*\n]+).*?\*\//is) || undefined
        };
        const mm = txt.match(/min\s*[: ]\s*([\-+]?\d+(?:\.\d+)?(?:[eE][\-+]?\d+)?).*?max\s*[: ]\s*([\-+]?\d+(?:\.\d+)?(?:[eE][\-+]?\d+)?)/is);
        if(mm){ meta.min = parseFloat(mm[1]); meta.max = parseFloat(mm[2]); }

        resolve({ width, height, z, palette, meta });
      };
      reader.onerror = ()=>reject(new Error("Failed to read file"));
      reader.readAsText(file);
    });
  }

  // ---------- main draw ----------
  function drawXPM(){
    const file = document.getElementById('xpmFile').files[0];
    if(!file){ alert('请选择 .xpm 文件'); return; }

    parseXPM(file).then(({width, height, z, palette, meta})=>{
      const step = Math.max(1, parseInt(document.getElementById('downsample').value || '1', 10));
      let zDs = downsampleMatrix(z, step);

      // flips
      if(document.getElementById('flipud').checked) zDs = zDs.slice().reverse();
      if(document.getElementById('fliplr').checked) zDs = zDs.map(row => row.slice().reverse());

      const H = zDs.length, W = zDs[0].length;
      const x = Array.from({length: W}, (_,i)=> i*step);
      const y = Array.from({length: H}, (_,i)=> i*step);

      // figure size
      const fs = (document.getElementById('figSize').value||'').split(',');
      const figW = parseInt(fs[0],10), figH = parseInt((fs[1]||'').trim(),10);
      const layoutSize = {};
      if(Number.isFinite(figW)) layoutSize.width = figW;
      if(Number.isFinite(figH)) layoutSize.height = figH;

      // axis ticks and ranges
      const dt = (document.getElementById('dtick').value||'').split(',');
      const xdtick = parseFloat(dt[0]); const ydtick = parseFloat(dt[1]);
      const xr = (document.getElementById('xrange').value||'').split(',').map(s=>parseFloat(s.trim()));
      const yr = (document.getElementById('yrange').value||'').split(',').map(s=>parseFloat(s.trim()));
      const xRange = (xr.length===2 && xr.every(v=>!Number.isNaN(v))) ? xr : undefined;
      const yRange = (yr.length===2 && yr.every(v=>!Number.isNaN(v))) ? yr : undefined;

      const cmapMode = document.getElementById('cmapMode').value;
      const colorscale = (cmapMode === 'xpm') ? buildColorscaleFromPalette(palette) : cmapMode;

      // numeric colorbar?
      let vmin, vmax, colorbarTitle = meta.legend || 'Palette';
      const mm = (document.getElementById('numMinMax').value || '').split(',').map(s=>parseFloat(s.trim()));
      if(mm.length===2 && mm.every(v=>!Number.isNaN(v))){
        vmin = mm[0]; vmax = mm[1];
        colorbarTitle = (meta.legend || 'Value') + ` [${vmin} .. ${vmax}]`;
      }else if(Number.isFinite(meta.min) && Number.isFinite(meta.max)){
        vmin = meta.min; vmax = meta.max;
        colorbarTitle = (meta.legend || 'Value') + ` [${vmin} .. ${vmax}]`;
      }

      const titleIn = document.getElementById('titleInput').value.trim();
      const axisIn = (document.getElementById('axisLabels').value || '').split(',');
      const xlabelIn = axisIn[0] ? axisIn[0].trim() : '';
      const ylabelIn = axisIn[1] ? axisIn[1].trim() : '';

      const layout = Object.assign({
        xaxis:{
          title: xlabelIn || meta.xlabel || 'Index i',
          dtick: Number.isNaN(xdtick)? undefined : xdtick,
          showline:true, mirror:true, linecolor:'#e0e0e0',
          range: xRange,
          constrain:'domain'
        },
        yaxis:{
          title: ylabelIn || meta.ylabel || 'Index j',
          dtick: Number.isNaN(ydtick)? undefined : ydtick,
          showline:true, mirror:true, linecolor:'#e0e0e0',
          range: yRange,
          scaleanchor:'x', scaleratio:1,
          constrain:'domain'
        },
        margin:{t:30},
        plot_bgcolor:'#fff', paper_bgcolor:'#fff',
        title: { text: titleIn || meta.title || 'Covariance Matrix (XPM)' }
      }, layoutSize);

      const trace = {
        type:'heatmap',
        x, y,
        z: zDs,
        colorscale: colorscale,
        showscale: true,
        zauto: false,
        zmin: 0,
        zmax: palette.length-1,
        colorbar: { title: colorbarTitle }
      };

      // 数值 min/max 时，把索引均匀映射到 [vmin..vmax]
      if(vmin !== undefined && vmax !== undefined){
        const scale = (vmax - vmin) / Math.max(1, (palette.length - 1));
        const zMap = zDs.map(row => row.map(v => Number.isFinite(v) ? (vmin + v*scale) : NaN));
        trace.z = zMap;
        trace.zmin = vmin;
        trace.zmax = vmax;
      }

      Plotly.newPlot('plot', [trace], layout);

      // meta output
      const metaDiv = document.getElementById('meta');
      const metaLines = [];
      metaLines.push(`size: ${width} x ${height}, palette colors: ${palette.length}`);
      if(meta.title)  metaLines.push(`title: ${meta.title}`);
      if(meta.xlabel) metaLines.push(`xlabel: ${meta.xlabel}`);
      if(meta.ylabel) metaLines.push(`ylabel: ${meta.ylabel}`);
      if(meta.legend) metaLines.push(`legend: ${meta.legend}`);
      if(Number.isFinite(meta.min) && Number.isFinite(meta.max)) metaLines.push(`min/max: ${meta.min} .. ${meta.max}`);
      metaDiv.textContent = metaLines.join('\n');
    }).catch(err=>{
      console.error(err);
      alert('解析/绘图失败：' + err.message);
    });
  }

  function downloadPNG(){
    const gd = document.getElementById('plot');
    Plotly.Plots.resize(gd);
    requestAnimationFrame(()=> {
      setTimeout(()=>{
        Plotly.toImage(gd, {
          format:'png',
          width: gd.layout?.width || gd.clientWidth || 1000,
          height: gd.layout?.height || gd.clientHeight || 760,
          scale: 2
        }).then((url)=>{
          const a=document.createElement('a'); a.href=url; a.download='covar_xpm_heatmap.png';
          document.body.appendChild(a); a.click(); a.remove();
        }).catch(e=>{ alert('导出失败：'+e.message); });
      }, 50);
    });
  }
</script>
</body>
</html>
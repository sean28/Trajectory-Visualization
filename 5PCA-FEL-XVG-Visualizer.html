<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>PCA-FEL Visualizer (2d_*.xvg)</title>
  <script src="./plotly-latest.min.js"></script>
  <style>
    body{font-family:Arial, sans-serif;background:#f5f6fa;margin:0;padding:2rem;}
    .container{max-width:1100px;margin:auto;background:#fff;padding:2rem;border-radius:12px;box-shadow:0 0 10px rgba(0,0,0,.05);}
    h2{text-align:center;margin-bottom:1rem;}
    .form-group{margin-bottom:1rem;}
    label{display:block;margin-bottom:.35rem;font-weight:bold;}
    input[type="text"],input[type="number"],select{
      width:50%;padding:.5rem .6rem;border:1px solid #ccc;border-radius:8px;font-size:14px;outline:none;transition:.2s;
    }
    input[type="text"]:focus,input[type="number"]:focus,select:focus{border-color:#007bff;}
    .row{display:flex;gap:1rem;flex-wrap:wrap;}
    .col{flex:1;min-width:220px}
    .file-row{display:flex;align-items:center;gap:.6rem;flex-wrap:wrap}
    button{padding:.55rem 1.1rem;border:none;background:#007bff;color:#fff;border-radius:8px;cursor:pointer}
    button:hover{background:#0056b3}
    .toolbar{display:flex;gap:.6rem;flex-wrap:wrap;margin-top:.5rem}
    #plot{margin-top:1rem;}
    #stats{font-family:monospace;background:#f7f7f7;padding:1rem;border-radius:8px;white-space:pre-wrap}
  </style>
</head>
<body>
<div class="container">
  <h2>PCA → Free Energy Landscape (FEL)</h2>

  <div class="form-group">
    <div class="file-row">
      <label class="col" style="flex:2;min-width:320px;">Upload 2D projection (.xvg, e.g. 2d_1_2.xvg)
        <input type="file" id="xvgFile" accept=".xvg">
      </label>
      <div class="toolbar">
        <button onclick="drawFEL()">Plot FEL</button>
        <button onclick="downloadPNG()">Download PNG</button>
      </div>
    </div>
  </div>

  <div class="form-group">
    <div class="row">
      <div class="col">
        <label>Figure Size (width,height)</label>
        <input id="figSize" type="text" value="1000,760">
      </div>
      <div class="col">
        <label>Bins</label>
        <input id="bins" type="number" min="20" max="300" step="5" value="120">
      </div>
      <div class="col">
        <label>Smoothing σ (bins)</label>
        <input id="sigma" type="number" min="0" step="0.1" value="0.8">
      </div>
      <div class="col">
        <label>Contours (#)</label>
        <input id="nLevels" type="number" min="2" max="20" step="1" value="8">
      </div>
      <div class="col">
        <label>Colormap</label>
        <select id="cmap">
          <option>Viridis</option>
          <option>Turbo</option>
          <option selected>Plasma</option>
          <option>Jet</option>
          <option>Cividis</option>
        </select>
      </div>
    </div>
  </div>

  <div class="form-group">
    <div class="row">
      <div class="col">
        <label>X-axis Label</label>
        <input id="xlabel" type="text" value="PC1">
      </div>
      <div class="col">
        <label>Y-axis Label</label>
        <input id="ylabel" type="text" value="PC2">
      </div>
      <div class="col">
        <label>Axis Ticks (dtick X,Y)</label>
        <input id="dtick" type="text" placeholder="auto,auto" value="">
      </div>
      <div class="col">
        <label>Axis Range (Xmin,Xmax)</label>
        <input id="xrange" type="text" placeholder="e.g. -5,5">
      </div>
      <div class="col">
        <label>Axis Range (Ymin,Ymax)</label>
        <input id="yrange" type="text" placeholder="e.g. -4,7">
      </div>
    </div>
  </div>

  <div id="plot"></div>

  <div class="form-group">
    <label>FEL Stats:</label>
    <div id="stats"></div>
  </div>
</div>

<script>
  // ---------- 1) 解析 xvg：支持 & 多数据集、三列 [time,PC1,PC2] 或两列 [PC1,PC2] ----------
  function parseXVG(file){
    return new Promise((resolve, reject)=>{
      const rx = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
      const reader = new FileReader();
      reader.onload = ()=>{
        const lines = reader.result.split(/\r?\n/);

        let x = [], y = [];
        let curX = [], curY = []; // 当前数据段（被 & 分隔）
        const flush = ()=>{
          if(curX.length && curY.length){ x.push(...curX); y.push(...curY); }
          curX = []; curY = [];
        };

        for(const raw of lines){
          const line = raw.trim();
          if(!line || line[0]==='@' || line[0]==='#') continue;
          if (/^&\s*$/.test(line)) { flush(); continue; }

          const nums = (line.match(rx) || []).map(Number).filter(v=>!Number.isNaN(v));
          if(!nums.length) continue;

          if(nums.length >= 3){ // [time, PC1, PC2]
            curX.push(nums[1]); curY.push(nums[2]);
          }else if(nums.length >= 2){ // [PC1, PC2]
            curX.push(nums[0]); curY.push(nums[1]);
          }
        }
        flush(); // 收尾

        if(x.length < 5){
          return reject(new Error(
            `Parsed only ${x.length} point(s). 需要两列 (PC1, PC2)。\\n` +
            `提示：如果是 proj_*.xvg 只有 time,PC1，请用 2d_*.xvg；\\n` +
            `或用 anaeig 重新输出：gmx anaeig -first 1 -last 2 -2d 2d_1_2.xvg`
          ));
        }
        resolve({x, y});
      };
      reader.onerror = ()=>reject(new Error("Failed to read file"));
      reader.readAsText(file);
    });
  }

  // ---------- 2) 工具函数：2D 直方图、Gaussian 平滑、分位数 ----------
  function histogram2D(x, y, bins){
    const xmin = Math.min(...x), xmax = Math.max(...x);
    const ymin = Math.min(...y), ymax = Math.max(...y);
    const nx = bins, ny = bins;
    const H = Array.from({length: ny}, ()=>Array(nx).fill(0));
    const xedges = Array.from({length: nx+1}, (_,i)=> xmin + (xmax-xmin)*i/nx);
    const yedges = Array.from({length: ny+1}, (_,i)=> ymin + (ymax-ymin)*i/ny);
    for(let k=0;k<x.length;k++){
      const xi = x[k], yi = y[k];
      let ix = Math.floor((xi - xmin) / (xmax - xmin) * nx);
      let iy = Math.floor((yi - ymin) / (ymax - ymin) * ny);
      if(ix<0) ix=0; if(ix>=nx) ix=nx-1;
      if(iy<0) iy=0; if(iy>=ny) iy=ny-1;
      H[iy][ix] += 1;
    }
    return {H, xedges, yedges};
  }
  function gaussianKernel1D(sigma){
    if(sigma <= 0) return [1];
    const radius = Math.max(1, Math.round(3*sigma));
    const k = [];
    for(let i=-radius;i<=radius;i++){
      k.push(Math.exp(-0.5*(i*i)/(sigma*sigma)));
    }
    const sum = k.reduce((a,b)=>a+b,0);
    return k.map(v=>v/sum);
  }
  function convolveSeparable(H, sigma){
    if(sigma <= 0) return H.map(r=>r.slice());
    const k = gaussianKernel1D(sigma);
    const r = Math.floor(k.length/2);
    const ny = H.length, nx = H[0].length;
    // 横向
    const A = Array.from({length: ny}, ()=>Array(nx).fill(0));
    for(let y=0;y<ny;y++){
      for(let x=0;x<nx;x++){
        let s=0;
        for(let t=-r;t<=r;t++){
          let xx = x+t; if(xx<0) xx=0; if(xx>=nx) xx=nx-1;
          s += H[y][xx]*k[t+r];
        }
        A[y][x]=s;
      }
    }
    // 纵向
    const B = Array.from({length: ny}, ()=>Array(nx).fill(0));
    for(let y=0;y<ny;y++){
      for(let x=0;x<nx;x++){
        let s=0;
        for(let t=-r;t<=r;t++){
          let yy = y+t; if(yy<0) yy=0; if(yy>=ny) yy=ny-1;
          s += A[yy][x]*k[t+r];
        }
        B[y][x]=s;
      }
    }
    return B;
  }
  function quantile(arr, q){
    const a = arr.slice().sort((m,n)=>m-n);
    const pos = (a.length-1)*q/100;
    const base = Math.floor(pos), rest = pos-base;
    if(a[base+1]!==undefined) return a[base] + rest*(a[base+1]-a[base]);
    return a[base];
  }

  // ---------- 3) 主函数：绘制 FEL ----------
  async function drawFEL(){
    try{
      const f = document.getElementById('xvgFile').files[0];
      if(!f){ alert('请先选择 2d_*.xvg 或包含 [time,PC1,PC2] 的 proj_*.xvg'); return; }

      const {x, y} = await parseXVG(f);
      const n = x.length;
      if(n < 5){ alert(`数据点太少：${n}`); return; }

      // 读取参数
      const bins = Math.max(10, Math.min(300, parseInt(document.getElementById('bins').value||'120',10)));
      const sigma = Math.max(0, parseFloat(document.getElementById('sigma').value||'0.8'));
      const cmap = document.getElementById('cmap').value;
      const nLevels = Math.max(2, parseInt(document.getElementById('nLevels').value||'8',10));

      // 直方图 + 平滑
      const {H, xedges, yedges} = histogram2D(x, y, bins);
      const Hs = convolveSeparable(H, sigma);

      // 转换为自由能 (kT)，最小值移到 0
      const ny = Hs.length, nx = Hs[0].length;
      let total = 0; for(let j=0;j<ny;j++) for(let i=0;i<nx;i++) total += Hs[j][i];
      const P = Array.from({length:ny},()=>Array(nx).fill(0));
      for(let j=0;j<ny;j++) for(let i=0;i<nx;i++) P[j][i] = Hs[j][i]/(total||1);

      const F = Array.from({length:ny},()=>Array(nx).fill(NaN));
      let fmin = Infinity, minPos=[0,0];
      for(let j=0;j<ny;j++){
        for(let i=0;i<nx;i++){
          const p = P[j][i];
          if(p>0){
            const v = -Math.log(p);
            F[j][i] = v;
            if(v < fmin){ fmin=v; minPos=[i,j]; }
          }
        }
      }
      for(let j=0;j<ny;j++) for(let i=0;i<nx;i++){
        if(Number.isFinite(F[j][i])) F[j][i] -= fmin;
      }

      // 网格中心坐标
      const Xc = xedges.slice(0,-1).map((v,i)=>0.5*(v + xedges[i+1]));
      const Yc = yedges.slice(0,-1).map((v,i)=>0.5*(v + yedges[i+1]));

      // 统计输出
      const pc1_min = Xc[minPos[0]];
      const pc2_min = Yc[minPos[1]];
      document.getElementById('stats').textContent =
        `Points=${n}\nGlobal minimum ~ (PC1=${pc1_min.toFixed(3)}, PC2=${pc2_min.toFixed(3)}), F=0.0 kT (relative)\n` +
        `Bins=${bins}, sigma=${sigma}, contours=${nLevels}`;

      // 图尺寸
      const fs = (document.getElementById('figSize').value||'').split(',');
      const figW = parseInt(fs[0],10), figH = parseInt((fs[1]||'').trim(),10);
      const layoutSize = {};
      if(Number.isFinite(figW)) layoutSize.width = figW;
      if(Number.isFinite(figH)) layoutSize.height = figH;

      // 坐标轴刻度和范围
      const dt = (document.getElementById('dtick').value||'').split(',');
      const xdtick = parseFloat(dt[0]); const ydtick = parseFloat(dt[1]);
      const xr = (document.getElementById('xrange').value||'').split(',').map(s=>parseFloat(s.trim()));
      const yr = (document.getElementById('yrange').value||'').split(',').map(s=>parseFloat(s.trim()));
      const xRange = (xr.length===2 && xr.every(v=>!Number.isNaN(v))) ? xr : undefined;
      const yRange = (yr.length===2 && yr.every(v=>!Number.isNaN(v))) ? yr : undefined;

      // 生成等高线水平
      const flatF = F.flat().filter(Number.isFinite);
      let levels = [];
      if(flatF.length){
        const qs = [];
        for(let i=1;i<=nLevels;i++) qs.push(i/(nLevels+1)*100);
        levels = qs.map(q=>quantile(flatF, q));
      }

      // 热力图 + 等高线
      const zmax = Math.max(...flatF);
      const heat = {
        type:'heatmap',
        x: Xc, y: Yc, z: F,
        colorscale: cmap,
        zauto: false,
        zmin: 0,
        zmax: zmax,
        colorbar: { title: 'Free Energy (kT)' }
      };
      const contour = {
        type:'contour',
        x: Xc, y: Yc, z: F,
        contours: { coloring:'none', showlines:true },
        line: { color:'black', width:1 },
        showscale:false
      };
      if(levels.length>=2){
        contour.contours = {
          coloring:'none', showlines:true,
          start: levels[0],
          end: levels[levels.length-1],
          size: (levels[levels.length-1]-levels[0])/(levels.length-1)
        };
      }

      Plotly.newPlot('plot', [heat, contour], Object.assign({
        xaxis:{ title: document.getElementById('xlabel').value, dtick: Number.isNaN(xdtick)? undefined : xdtick, showline:true, mirror:true, linecolor:'#e0e0e0', range:xRange },
        yaxis:{ title: document.getElementById('ylabel').value, dtick: Number.isNaN(ydtick)? undefined : ydtick, showline:true, mirror:true, linecolor:'#e0e0e0', range:yRange, scaleanchor:'x', scaleratio:1, constrain:'domain' },
        margin:{t:30},
        plot_bgcolor:'#fff', paper_bgcolor:'#fff'
      }, layoutSize));
    }catch(err){
      console.error(err);
      alert('绘图失败：'+ err.message);
    }
  }

  // ---------- 4) 下载 PNG ----------
  function downloadPNG(){
    const gd = document.getElementById('plot');
    Plotly.Plots.resize(gd);
    requestAnimationFrame(()=> {
      setTimeout(()=>{
        Plotly.toImage(gd, {
          format:'png',
          width: gd.layout?.width || gd.clientWidth || 1000,
          height: gd.layout?.height || gd.clientHeight || 760,
          scale: 2
        }).then((url)=>{
          const a=document.createElement('a'); a.href=url; a.download='FEL_PC1_PC2.png';
          document.body.appendChild(a); a.click(); a.remove();
        }).catch(e=>{ alert('导出失败：'+e.message); });
      }, 50);
    });
  }
</script>
</body>
</html>